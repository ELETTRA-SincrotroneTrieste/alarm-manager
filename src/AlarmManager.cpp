/*----- PROTECTED REGION ID(AlarmManager.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        AlarmManager.cpp
//
// description : C++ source for the AlarmManager class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               AlarmManager are implemented in this file.
//
// project :     AlarmManager
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
// Elettra-Sincrotrone Trieste S.C.p.A. di interesse nazionale
// Strada Statale 14 - km 163,5 in AREA Science Park
// 34149 Basovizza, Trieste ITALY
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <AlarmManager.h>
#include <AlarmManagerClass.h>
#include <netdb.h> //for getaddrinfo

/*----- PROTECTED REGION END -----*/	//	AlarmManager.cpp

/**
 *  AlarmManager class description:
 *    Manager for Alarm Handlers
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name     |  Method name
//================================================================
//  State            |  Inherited (no method)
//  Status           |  Inherited (no method)
//  Load             |  load
//  Remove           |  remove
//  Modify           |  modify
//  GetAlarmInfo     |  get_alarm_info
//  SearchAlarm      |  search_alarm
//  ReLoadAll        |  re_load_all
//  ResetStatistics  |  reset_statistics
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  tag             |  Tango::DevString	Scalar
//  formula         |  Tango::DevString	Scalar
//  message         |  Tango::DevString	Scalar
//  priority        |  Tango::DevString	Scalar
//  group           |  Tango::DevString	Scalar
//  shlvd_time      |  Tango::DevLong	Scalar
//  on_delay        |  Tango::DevLong	Scalar
//  off_delay       |  Tango::DevLong	Scalar
//  on_command      |  Tango::DevString	Scalar
//  off_command     |  Tango::DevString	Scalar
//  enabled         |  Tango::DevBoolean	Scalar
//  alarmDevice     |  Tango::DevString	Scalar
//  alarmList       |  Tango::DevString	Spectrum  ( max = 10000)
//  alarmFrequency  |  Tango::DevDouble	Spectrum  ( max = 10000)
//================================================================

namespace AlarmManager_ns
{
/*----- PROTECTED REGION ID(AlarmManager::namespace_starting) ENABLED START -----*/

//	static initializations
map<string, string> AlarmManager::domain_map;

typedef std::vector<string> Vec;
struct Contained
{
    Vec &_sequence;
    Vec _sequence2;
    Contained(Vec &vec) : _sequence(vec){
    	Vec _sequence_upper(vec);
    	for(Vec::iterator it = _sequence_upper.begin(); it!=_sequence_upper.end(); it++)
    	{
    		string result("");
   			string::size_type found;
   			string separator(":");
   			found = it->find_first_of(separator);
    		if(found != string::npos) {
    			if(found > 0) {
    				result = it->substr(0,found);
    			}
    		}
    		else if(it->length() > 0) {
    			result = *it;
    		}
    		std::transform(result.begin(), result.end(), result.begin(), (int(*)(int))toupper);
    		_sequence2.push_back(result);
    	}
    }
    bool operator()(string i) const
    {
		string result("");
		string::size_type found;
		string separator(":");
		found = i.find_first_of(separator);
		if(found != string::npos) {
			if(found > 0) {
				result = i.substr(0,found);
			}
		}
		else if(i.length() > 0) {
			result = i;
		}
    	std::transform(result.begin(), result.end(), result.begin(), (int(*)(int))toupper);
        return _sequence2.end() != std::find(_sequence2.begin(), _sequence2.end(), result);
    }
};

/*----- PROTECTED REGION END -----*/	//	AlarmManager::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::AlarmManager()
 *	Description : Constructors for a Tango device
 *                implementing the classAlarmManager
 */
//--------------------------------------------------------
AlarmManager::AlarmManager(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(AlarmManager::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::constructor_1
}
//--------------------------------------------------------
AlarmManager::AlarmManager(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(AlarmManager::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::constructor_2
}
//--------------------------------------------------------
AlarmManager::AlarmManager(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(AlarmManager::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void AlarmManager::delete_device()
{
	DEBUG_STREAM << "AlarmManager::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::delete_device
	delete[] attr_tag_read;
	delete[] attr_formula_read;
	delete[] attr_message_read;
	delete[] attr_priority_read;
	delete[] attr_group_read;
	delete[] attr_shlvd_time_read;
	delete[] attr_on_delay_read;
	delete[] attr_off_delay_read;
	delete[] attr_on_command_read;
	delete[] attr_off_command_read;
	delete[] attr_enabled_read;
	delete[] attr_alarmDevice_read;
	delete[] attr_alarmList_read;
	delete[] attr_alarmFrequency_read;
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void AlarmManager::init_device()
{
	DEBUG_STREAM << "AlarmManager::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	attr_alarmList_read = NULL;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_tag_read = new Tango::DevString[1];
	attr_formula_read = new Tango::DevString[1];
	attr_message_read = new Tango::DevString[1];
	attr_priority_read = new Tango::DevString[1];
	attr_group_read = new Tango::DevString[1];
	attr_shlvd_time_read = new Tango::DevLong[1];
	attr_on_delay_read = new Tango::DevLong[1];
	attr_off_delay_read = new Tango::DevLong[1];
	attr_on_command_read = new Tango::DevString[1];
	attr_off_command_read = new Tango::DevString[1];
	attr_enabled_read = new Tango::DevBoolean[1];
	attr_alarmDevice_read = new Tango::DevString[1];
	attr_alarmList_read = new Tango::DevString[10000];
	attr_alarmFrequency_read = new Tango::DevDouble[10000];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(AlarmManager::init_device) ENABLED START -----*/
	
	//	Initialize device
	*attr_tag_read = CORBA::string_dup("");
	*attr_formula_read = CORBA::string_dup("");
	*attr_message_read = CORBA::string_dup("");
	*attr_priority_read = CORBA::string_dup("");
	*attr_group_read = CORBA::string_dup("");
	*attr_shlvd_time_read = -1;
	*attr_on_delay_read = 0;
	*attr_off_delay_read = 0;
	*attr_on_command_read = CORBA::string_dup("");
	*attr_off_command_read = CORBA::string_dup("");
	*attr_enabled_read = true;
	handler_t tmp;
	//for(auto it = handlerList.begin(); it!= handlerList.end(); it++)
	for(auto it : handlerList)
	//for(vector<string>::iterator it = handlerList.begin(); it!= handlerList.end(); it++)
	{
		try
		{
			tmp.dp = std::unique_ptr<Tango::DeviceProxy>(new Tango::DeviceProxy(it));
		}
		catch(Tango::DevFailed &e)
		{
			tmp.dp = std::unique_ptr<Tango::DeviceProxy>(nullptr);
		}
		string hndlname(it);
		fix_tango_host(hndlname);
		DEBUG_STREAM << __func__<<": adding handler:"<<hndlname;
		handler_list_fix.push_back(hndlname);
		handlerMap.insert(make_pair(hndlname,std::move(tmp)));
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::init_device
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void AlarmManager::get_device_property()
{
	/*----- PROTECTED REGION ID(AlarmManager::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("HandlerList"));
	dev_prop.push_back(Tango::DbDatum("MaxSearchSize"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on AlarmManagerClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		AlarmManagerClass	*ds_class =
			(static_cast<AlarmManagerClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize HandlerList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  handlerList;
		else {
			//	Try to initialize HandlerList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  handlerList;
		}
		//	And try to extract HandlerList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  handlerList;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize MaxSearchSize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxSearchSize;
		else {
			//	Try to initialize MaxSearchSize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxSearchSize;
		}
		//	And try to extract MaxSearchSize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxSearchSize;

	}

	/*----- PROTECTED REGION ID(AlarmManager::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmManager::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void AlarmManager::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(AlarmManager::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	AlarmManager::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : AlarmManager::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void AlarmManager::always_executed_hook()
{
	DEBUG_STREAM << "AlarmManager::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"AlarmManager::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(AlarmManager::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	timespec now;
	clock_gettime(CLOCK_MONOTONIC,&now);
	if((now.tv_sec - last_stat.tv_sec + (double)(now.tv_nsec - last_stat.tv_nsec)/1e9) < 2.0)
	{
		return;
	}
	clock_gettime(CLOCK_MONOTONIC,&last_stat);
	bool handler_fault = false;
	for(auto itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		if(itmap->second.dp.get() == nullptr)
		{
			DEBUG_STREAM << __func__ << ": reconnecting to " << itmap->first;
			try
			{
				itmap->second.dp = std::unique_ptr<Tango::DeviceProxy>(new Tango::DeviceProxy(itmap->first.c_str()));
			}
			catch(Tango::DevFailed &e)
			{
				itmap->second.dp = std::unique_ptr<Tango::DeviceProxy>(nullptr);
			}
		}
		else
        {
			try
			{
				if (!itmap->second.dp->ping())
				{
					INFO_STREAM << "AlarmManager::always_executed_hook() handler " << itmap->first << " PING NOK" << endl;
					handler_fault = true;
				}
			}
			catch(Tango::DevFailed &e)
			{
				INFO_STREAM << "AlarmManager::always_executed_hook() handler " << itmap->first << " Exception" << endl;
				handler_fault = true;
			}
        }
	}
	if(handler_fault)
	{
		DEBUG_STREAM << __func__<<": setting state FAULT "<<endl;
		set_state(Tango::FAULT);
		set_status("At least one handler Not Responding");
		return;
	}
	Tango::DevState stat = Tango::ON;
	string status("Everything is OK");
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DevState stat_arch;
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("State");
				if(!Dout.is_empty())
				{
					Dout >> stat_arch;
					if(stat_arch != Tango::ON)
					{
						stat = Tango::ALARM;
						status = string("At least one alarm present");
						break;
					}
				}
			}
			else
			{
				stat = Tango::FAULT;
				string status("At least one handler Not Responding");
				break;
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read State from " << itmap->first;
			stat = Tango::FAULT;
			status = string("At least one handler Not Responding");
			break;
		}
	}
	if(get_state() != stat)
	{
		set_state(stat);
		set_status(status);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void AlarmManager::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "AlarmManager::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : AlarmManager::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void AlarmManager::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "AlarmManager::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute tag related method
 *	Description: Alarm tag
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_tag(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_tag(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_tag) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_tag_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_tag
}
//--------------------------------------------------------
/**
 *	Write attribute tag related method
 *	Description: Alarm tag
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_tag(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_tag(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_tag) ENABLED START -----*/
	string tagname(w_val);
	//remove white spaces:
	tagname.erase (std::remove (tagname.begin(), tagname.end(), ' '), tagname.end());
	*attr_tag_read = CORBA::string_dup(tagname.c_str()); //TODO: check if already existing
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_tag
}
//--------------------------------------------------------
/**
 *	Read attribute formula related method
 *	Description: Alarm formula
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_formula(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_formula(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_formula) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_formula_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_formula
}
//--------------------------------------------------------
/**
 *	Write attribute formula related method
 *	Description: Alarm formula
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_formula(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_formula(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_formula) ENABLED START -----*/
	string formula(w_val);
	//remove white spaces:
	formula.erase (std::remove (formula.begin(), formula.end(), ' '), formula.end());
	*attr_formula_read = CORBA::string_dup(formula.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_formula
}
//--------------------------------------------------------
/**
 *	Read attribute message related method
 *	Description: Alarm message
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_message(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_message(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_message) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_message_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_message
}
//--------------------------------------------------------
/**
 *	Write attribute message related method
 *	Description: Alarm message
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_message(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_message(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_message) ENABLED START -----*/
	string msg(w_val);//TODO: escape ?
	*attr_message_read = CORBA::string_dup(msg.c_str());	
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_message
}
//--------------------------------------------------------
/**
 *	Read attribute priority related method
 *	Description: Alarm priority
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_priority(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_priority(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_priority) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_priority_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_priority
}
//--------------------------------------------------------
/**
 *	Write attribute priority related method
 *	Description: Alarm priority
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_priority(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_priority(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_priority) ENABLED START -----*/
	string priority(w_val);
	*attr_priority_read = CORBA::string_dup(priority.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_priority
}
//--------------------------------------------------------
/**
 *	Read attribute group related method
 *	Description: Alarm group
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_group(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_group(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_group) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_group_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_group
}
//--------------------------------------------------------
/**
 *	Write attribute group related method
 *	Description: Alarm group
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_group(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_group(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_group) ENABLED START -----*/
	string group(w_val);
	*attr_group_read = CORBA::string_dup(group.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_group
}
//--------------------------------------------------------
/**
 *	Read attribute shlvd_time related method
 *	Description: Alarm shelved time in minutes, -1 if disabled
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_shlvd_time(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_shlvd_time(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_shlvd_time) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_shlvd_time_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_shlvd_time
}
//--------------------------------------------------------
/**
 *	Write attribute shlvd_time related method
 *	Description: Alarm shelved time in minutes, -1 if disabled
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_shlvd_time(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_shlvd_time(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_shlvd_time) ENABLED START -----*/
	*attr_shlvd_time_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_shlvd_time
}
//--------------------------------------------------------
/**
 *	Read attribute on_delay related method
 *	Description: Alarm delay time in seconds before becoming active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_on_delay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_on_delay(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_on_delay) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_on_delay_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_on_delay
}
//--------------------------------------------------------
/**
 *	Write attribute on_delay related method
 *	Description: Alarm delay time in seconds before becoming active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_on_delay(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_on_delay(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_on_delay) ENABLED START -----*/
	*attr_on_delay_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_on_delay
}
//--------------------------------------------------------
/**
 *	Read attribute off_delay related method
 *	Description: Alarm delay time in seconds before becoming non active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_off_delay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_off_delay(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_off_delay) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_off_delay_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_off_delay
}
//--------------------------------------------------------
/**
 *	Write attribute off_delay related method
 *	Description: Alarm delay time in seconds before becoming non active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_off_delay(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_off_delay(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_off_delay) ENABLED START -----*/
	*attr_off_delay_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_off_delay
}
//--------------------------------------------------------
/**
 *	Read attribute on_command related method
 *	Description: Alarm command executed when becoming active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_on_command(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_on_command(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_on_command) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_on_command_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_on_command
}
//--------------------------------------------------------
/**
 *	Write attribute on_command related method
 *	Description: Alarm command executed when becoming active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_on_command(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_on_command(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_on_command) ENABLED START -----*/
	string on_command(w_val);
	*attr_on_command_read = CORBA::string_dup(on_command.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_on_command
}
//--------------------------------------------------------
/**
 *	Read attribute off_command related method
 *	Description: Alarm command executed when becoming non active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_off_command(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_off_command(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_off_command) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_off_command_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_off_command
}
//--------------------------------------------------------
/**
 *	Write attribute off_command related method
 *	Description: Alarm command executed when becoming non active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_off_command(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_off_command(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_off_command) ENABLED START -----*/
	string off_command(w_val);
	*attr_off_command_read = CORBA::string_dup(off_command.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_off_command
}
//--------------------------------------------------------
/**
 *	Read attribute enabled related method
 *	Description: Alarm enabled
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_enabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_enabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_enabled) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_enabled_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_enabled
}
//--------------------------------------------------------
/**
 *	Write attribute enabled related method
 *	Description: Alarm enabled
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_enabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_enabled(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_enabled) ENABLED START -----*/
	*attr_enabled_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_enabled
}
//--------------------------------------------------------
/**
 *	Read attribute alarmDevice related method
 *	Description: Alarm Handler device
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_alarmDevice(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_alarmDevice(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_alarmDevice) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_alarmDevice_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_alarmDevice
}
//--------------------------------------------------------
/**
 *	Write attribute alarmDevice related method
 *	Description: Alarm Handler device
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_alarmDevice(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_alarmDevice(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_alarmDevice) ENABLED START -----*/
	string tagname(w_val);
	fix_tango_host(tagname);
	*attr_alarmDevice_read = CORBA::string_dup(tagname.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_alarmDevice
}
//--------------------------------------------------------
/**
 *	Read attribute alarmList related method
 *	Description: List of all alarms
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void AlarmManager::read_alarmList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_alarmList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_alarmList) ENABLED START -----*/
	vector<string> complete_list;
	DEBUG_STREAM << __func__ << ": complete list -> size=" << complete_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmList");
				if(!Dout.is_empty())
					Dout >> itmap->second.alm_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
				itmap->second.alm_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
			itmap->second.alm_list.clear();
		}
		DEBUG_STREAM << __func__ << ": partial list -> size=" << itmap->second.alm_list.size() << endl;
		complete_list.insert(complete_list.end(),itmap->second.alm_list.begin(), itmap->second.alm_list.end());
		DEBUG_STREAM << __func__ << ": building complete list -> size=" << complete_list.size() << endl;
	}
	size_t i=0;
	for(auto it : complete_list)
	{
		attr_alarmList_read[i++] = CORBA::string_dup(it.c_str());
	}
	//	Set the attribute value
	attr.set_value(attr_alarmList_read, complete_list.size());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_alarmList
}
//--------------------------------------------------------
/**
 *	Read attribute alarmFrequency related method
 *	Description: List of frequency of evaluation of all alarms
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void AlarmManager::read_alarmFrequency(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_alarmFrequency(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_alarmFrequency) ENABLED START -----*/
	vector<double> freq_list;
	DEBUG_STREAM << __func__ << ": complete list -> size=" << freq_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmFrequency");
				if(!Dout.is_empty())
					Dout >> itmap->second.freq_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmFrequency from " << itmap->first;
				itmap->second.freq_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmFrequency from " << itmap->first;
			itmap->second.freq_list.clear();
		}
		DEBUG_STREAM << __func__ << ": partial list -> size=" << itmap->second.freq_list.size() << endl;
		freq_list.insert(freq_list.end(),itmap->second.freq_list.begin(), itmap->second.freq_list.end());
		DEBUG_STREAM << __func__ << ": building complete list -> size=" << freq_list.size() << endl;
	}
	size_t i=0;
	for(auto it : freq_list)
	{
		attr_alarmFrequency_read[i++] = it;
	}
	//	Set the attribute value
	attr.set_value(attr_alarmFrequency_read, freq_list.size());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_alarmFrequency
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void AlarmManager::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(AlarmManager::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Load related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void AlarmManager::load()
{
	DEBUG_STREAM << "AlarmManager::Load()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::load) ENABLED START -----*/
	
	//	Add your own code
	string tagname(*attr_tag_read);
	string hndlrname = find_handler(tagname);

	auto itmapnew = handlerMap.find(hndlrname);
	if(itmapnew != handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' already configured in '"<<hndlrname<<"'";
		Tango::Except::throw_exception( \
					(const char*)"Already configured", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	hndlrname=string(*attr_alarmDevice_read);
	itmapnew = handlerMap.find(hndlrname);
	if(itmapnew == handlerMap.end())
	{
		stringstream tmp;
		tmp << "handler '" << hndlrname << "' not found";
		Tango::Except::throw_exception( \
					(const char*)"handler not found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	//------4: Assign to existing EventSubscriber--------------------------
	if(itmapnew->second.dp)
	{
		string load_str="tag="+tagname+";formula="+string(*attr_formula_read)+";message="+string(*attr_message_read)+";priority="+string(*attr_priority_read)+";group="+string(*attr_group_read)+";shlvd_time="+to_string(*attr_shlvd_time_read)+";on_delay="+to_string(*attr_on_delay_read)+";off_delay="+to_string(*attr_off_delay_read)+";on_command="+string(*attr_on_command_read)+";off_command="+string(*attr_off_command_read)+"enabled="+to_string(*attr_enabled_read);
		Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
		Tango::DeviceData Din;
		Din << load_argin;
		itmapnew->second.dp->command_inout("Load",Din);
	}
	else
	{
		stringstream tmp;
		tmp << "handler " << itmapnew->first << " Not Responding";
		Tango::Except::throw_exception( \
					(const char*)"Error", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::load
}
//--------------------------------------------------------
/**
 *	Command Remove related method
 *	Description: 
 *
 *	@param argin tagname
 */
//--------------------------------------------------------
void AlarmManager::remove(Tango::DevString argin)
{
	DEBUG_STREAM << "AlarmManager::Remove()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::remove) ENABLED START -----*/
	
	//	Add your own code
	string tagname(argin);
	string hndlrname = find_handler(tagname);
	DEBUG_STREAM << __func__ << ": found handler '"<< hndlrname <<"' for alarm '"<<tagname<<"'"<<endl;
	auto itmap = handlerMap.find(hndlrname);
	if(itmap == handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' handler '" << hndlrname << "' NOT FOUND";
		Tango::Except::throw_exception( \
					(const char*)"NOT FOUND", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}
	if(itmap->second.dp)
	{
		Tango::DeviceData Din;
		Din << tagname;
		itmap->second.dp->command_inout("Remove",Din);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::remove
}
//--------------------------------------------------------
/**
 *	Command Modify related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void AlarmManager::modify()
{
	DEBUG_STREAM << "AlarmManager::Modify()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::modify) ENABLED START -----*/
	
	//	Add your own code

	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::modify
}
//--------------------------------------------------------
/**
 *	Command GetAlarmInfo related method
 *	Description: Returns the complete attribute info as an array of key=value
 *
 *	@param argin Alarm name followed optionally by wanted key names
 *	@returns Complete attribute info as an array of key=value
 */
//--------------------------------------------------------
Tango::DevVarStringArray *AlarmManager::get_alarm_info(const Tango::DevVarStringArray *argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "AlarmManager::GetAlarmInfo()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::get_alarm_info) ENABLED START -----*/
	
	//	Add your own code
	vector<string> param;
	param << (*argin);
	if(param.size() < 1)
	{
		Tango::Except::throw_exception( \
			(const char*)"BAD PARAM", \
			(const char*)"Expected at least 1 parameter", \
			(const char*)__func__, Tango::ERR);
	}
	string tagname(param[0]);
	string hndlrname = find_handler(tagname);
	DEBUG_STREAM << __func__ << ": found handler '"<< hndlrname <<"' for alarm '"<<tagname<<"'"<<endl;
	auto itmap = handlerMap.find(hndlrname);
	if(itmap == handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' handler '" << hndlrname << "' NOT FOUND";
		Tango::Except::throw_exception( \
					(const char*)"NOT FOUND", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	argout = new Tango::DevVarStringArray();
	if(itmap->second.dp)
	{
		Tango::DeviceData Din, Dout;
		Din << param;
		Dout = itmap->second.dp->command_inout("GetAlarmInfo",Din);
		vector<string> resp;
		Dout >> resp;
		argout->length(resp.size());
		size_t i=0;
		for(auto it : resp)
		{
			(*argout)[i] = CORBA::string_dup(it.c_str());
			i++;	
		}
	}
	else
	{
		argout->length(0);
	}
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::get_alarm_info
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SearchAlarm related method
 *	Description: Return list of configured alarms matching the filter string
 *
 *	@param argin String containing a filter for output, if empty or * return all alarms
 *	@returns Configured alarms
 */
//--------------------------------------------------------
Tango::DevVarStringArray *AlarmManager::search_alarm(Tango::DevString argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "AlarmManager::SearchAlarm()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::search_alarm) ENABLED START -----*/
	
	//	Add your own code
	attribute_search_list_str.clear();
	vector<string> complete_list;
	DEBUG_STREAM << "AlarmManager::SearchAlarm()  - 0 complete list -> size=" << complete_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmList");
				if(!Dout.is_empty())
					Dout >> itmap->second.alm_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
				itmap->second.alm_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
			itmap->second.alm_list.clear();
		}
		DEBUG_STREAM << "AlarmManager::SearchAlarm()  - partial list -> size=" << itmap->second.alm_list.size() << endl;
		complete_list.insert(complete_list.end(),itmap->second.alm_list.begin(), itmap->second.alm_list.end());
		DEBUG_STREAM << "AlarmManager::SearchAlarm()  - building complete list -> size=" << complete_list.size() << endl;
	}


	string filter(argin);
	size_t found;
	for(vector<string>::iterator it = complete_list.begin(); it != complete_list.end(); it++)
	{
		found = 0;
		if(filter.length() != 0)
		{
			found = it->find(filter);
		}
		if((filter.length() == 0) || (found != string::npos))
		{
			attribute_search_list_str.push_back(*it);
			DEBUG_STREAM << "AlarmManager::SearchAlarm()  - found: " << *it << endl;
			if(attribute_search_list_str.size() >= maxSearchSize)
				break;
		}
	}
	DEBUG_STREAM << "AlarmManager::SearchAlarm()  - found list -> size=" << attribute_search_list_str.size() << endl;

	argout = new Tango::DevVarStringArray();
	argout->length(attribute_search_list_str.size());
	int i = 0;
	for (vector<string>::iterator it= attribute_search_list_str.begin(); it != attribute_search_list_str.end(); it++)
	{
		DEBUG_STREAM << "AlarmManager::SearchAlarm()  - result list -> copying=" << *it << endl;
		(*argout)[i] = CORBA::string_dup(it->c_str());
		i++;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::search_alarm
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReLoadAll related method
 *	Description: Reload all alarms from attribute properties
 *
 */
//--------------------------------------------------------
void AlarmManager::re_load_all()
{
	DEBUG_STREAM << "AlarmManager::ReLoadAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::re_load_all) ENABLED START -----*/
	
	//	Add your own code
	for(handler_map_t::iterator it = handlerMap.begin(); it != handlerMap.end(); it++)
	{
		if(it->second.dp)
			it->second.dp->command_inout("ReLoadAll");
		else
			INFO_STREAM << __func__ << ": unable to ReLoadAll on " << it->first;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::re_load_all
}
//--------------------------------------------------------
/**
 *	Command ResetStatistics related method
 *	Description: Reset statistics
 *
 */
//--------------------------------------------------------
void AlarmManager::reset_statistics()
{
	DEBUG_STREAM << "AlarmManager::ResetStatistics()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::reset_statistics) ENABLED START -----*/
	
	//	Add your own code
	for(handler_map_t::iterator it = handlerMap.begin(); it != handlerMap.end(); it++)
	{
		if(it->second.dp)
			it->second.dp->command_inout("ResetStatistics");
		else
			INFO_STREAM << __func__ << ": unable to ResetStatistics on " << it->first;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::reset_statistics
}
//--------------------------------------------------------
/**
 *	Method      : AlarmManager::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void AlarmManager::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(AlarmManager::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::add_dynamic_commands
}

/*----- PROTECTED REGION ID(AlarmManager::namespace_ending) ENABLED START -----*/

//	Additional Methods
string AlarmManager::find_handler(string &tagname)
{
	DEBUG_STREAM << __func__<< ": entering with " << tagname;
	string handler("");
	for(auto itmap = handlerMap.begin(); itmap != handlerMap.end(); ++itmap)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmList");
				if(!Dout.is_empty())
					Dout >> itmap->second.alm_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
				itmap->second.alm_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
			itmap->second.alm_list.clear();
		}
		for(auto itattr : itmap->second.alm_list)
		{
			if(tagname.length() != 0 && itattr == tagname)	
			{
				DEBUG_STREAM << __func__<< ": FOUND " << itattr;
				handler = itmap->first;
				return handler;
			}
		}
	}
	return handler;
}

void AlarmManager::fix_tango_host(string &attr)
{
	std::transform(attr.begin(), attr.end(), attr.begin(), (int(*)(int))tolower);		//transform to lowercase
	string::size_type	start = attr.find("tango://");
	//if not fqdn, add TANGO_HOST
	if (start == string::npos)
	{
		//TODO: get from device/class/global property
		char	*env = getenv("TANGO_HOST");
		if (env==NULL)
		{
			return;
		}
		else
		{
			string	s(env);
			add_domain(s);
			attr = string("tango://") + s + "/" + attr;
			return;
		}
	}
	string facility = get_only_tango_host(attr);
	add_domain(facility);
	string attr_name = get_only_attr_name(attr);
	attr = string("tango://")+ facility + string("/") + attr_name;
}

void AlarmManager::add_domain(string &str)
{
	string::size_type	end1 = str.find(".");
	if (end1 == string::npos)
	{
		//get host name without tango://
		string::size_type	start = str.find("tango://");
		if (start == string::npos)
		{
			start = 0;
		}
		else
		{
			start = 8;	//tango:// len
		}
		string::size_type	end2 = str.find(":", start);

		string th = str.substr(start, end2);
		string with_domain = str;

		map<string,string>::iterator it_domain = domain_map.find(th);
		if(it_domain != domain_map.end())
		{
			with_domain = it_domain->second;
			//cout << __func__ <<": found domain in map -> " << with_domain<<endl;
			str = with_domain;
			return;
		}

		struct addrinfo hints;
//		hints.ai_family = AF_INET; // use AF_INET6 to force IPv6
//		hints.ai_flags = AI_CANONNAME|AI_CANONIDN;
		memset(&hints, 0, sizeof hints);
		hints.ai_family = AF_UNSPEC; /*either IPV4 or IPV6*/
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_flags = AI_CANONNAME;
		struct addrinfo *result;
		int ret = getaddrinfo(th.c_str(), NULL, &hints, &result);
		if (ret != 0)
		{
			cout << __func__<< ": getaddrinfo error='" << gai_strerror(ret)<<"' while looking for " << th<<endl;
			return;
		}
		if(result == NULL)
		{
			cout << __func__ << ": getaddrinfo did not return domain information for " 
			     << th << " (result == NULL)" << endl;
			return;
		}
		if (result->ai_canonname == NULL)
		{
			cout << __func__ << ": getaddrinfo did not return domain information for " 
			     << th << " (result->ai_canonname == NULL)" << endl;
			freeaddrinfo(result);
			return;
		}
		with_domain = string(result->ai_canonname) + str.substr(end2);
		//cout << __func__ <<": found domain -> " << with_domain<<endl;
		domain_map.insert(make_pair(th, with_domain));
		freeaddrinfo(result); // all done with this structure
		str = with_domain;
		return;
	}
	else
	{
		return;
	}
}

string AlarmManager::get_only_attr_name(const string &str)
{
	string::size_type	start = str.find("tango://");
	if (start == string::npos)
		return str;
	else
	{
		start += 8; //	"tango://" length
		start = str.find('/', start);
		start++;
		string	tagname = str.substr(start);
		return tagname;
	}
}

string AlarmManager::get_only_tango_host(const string &str)
{
	string::size_type	start = str.find("tango://");
	if (start == string::npos)
	{
		return "unknown";
	}
	else
	{
		start += 8; //	"tango://" length
		string::size_type	end = str.find('/', start);
		string th = str.substr(start, end-start);
		return th;
	}
}

string AlarmManager::remove_domain(const string &str)
{
	string::size_type	end1 = str.find(".");
	if (end1 == string::npos)
	{
		return str;
	}
	else
	{
		string::size_type	start = str.find("tango://");
		if (start == string::npos)
		{
			start = 0;
		}
		else
		{
			start = 8;	//tango:// len
		}
		string::size_type	end2 = str.find(":", start);
		if(end1 > end2)	//'.' not in the tango host part
			return str;
		string th = str.substr(0, end1);
		th += str.substr(end2, str.size()-end2);
		return th;
	}
}

//return false if str1 >= str2
bool compare_tango_names(string str1, string str2)
{
//	cout << __func__<< ": entering with '" << str1<<"' - '" << str2<<"'" << endl;
	if(str1 == str2)
	{
//		cout << __func__<< ": EQUAL 1 -> '" << str1<<"'=='" << str2<<"'" << endl;
		return false;
	}
	AlarmManager::fix_tango_host(str1);
	AlarmManager::fix_tango_host(str2);
	if(str1 == str2)
	{
//		cout << __func__<< ": EQUAL 2 -> '" << str1<<"'=='" << str2<<"'" << endl;
		return false;
	}
	string str1_nd = AlarmManager::remove_domain(str1);
	string str2_nd = AlarmManager::remove_domain(str2);
	if(str1_nd == str2_nd)
	{
//		cout << __func__<< ": EQUAL 3 -> '" << str1_nd<<"'=='" << str2_nd<<"'" << endl;
		return false;
	}
	bool result=str1_nd<str2_nd;
//	cout << __func__<< ": DIFFERENTS -> '" << str1_nd<< (result ? "'<'" : "'>'") << str2_nd<<"'" << endl;
	return result;
}

/*----- PROTECTED REGION END -----*/	//	AlarmManager::namespace_ending
} //	namespace
