/*----- PROTECTED REGION ID(AlarmManager.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        AlarmManager.cpp
//
// description : C++ source for the AlarmManager class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               AlarmManager are implemented in this file.
//
// project :     AlarmManager
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
// Elettra-Sincrotrone Trieste S.C.p.A. di interesse nazionale
// Strada Statale 14 - km 163,5 in AREA Science Park
// 34149 Basovizza, Trieste ITALY
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <AlarmManager.h>
#include <AlarmManagerClass.h>
#include <netdb.h> //for getaddrinfo
#include <string>

/*----- PROTECTED REGION END -----*/	//	AlarmManager.cpp

/**
 *  AlarmManager class description:
 *    Manager for Alarm Handlers
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name     |  Method name
//================================================================
//  State            |  Inherited (no method)
//  Status           |  Inherited (no method)
//  Load             |  load
//  Remove           |  remove
//  Modify           |  modify
//  GetAlarmInfo     |  get_alarm_info
//  SearchAlarmName  |  search_alarm_name
//  ReLoadAll        |  re_load_all
//  ResetStatistics  |  reset_statistics
//  LoadConf         |  load_conf
//  SearchAlarmConf  |  search_alarm_conf
//  ModifyConf       |  modify_conf
//  AddArchiver      |  add_archiver
//  Rename           |  rename
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  tag               |  Tango::DevString	Scalar
//  formula           |  Tango::DevString	Scalar
//  message           |  Tango::DevString	Scalar
//  priority          |  Tango::DevString	Scalar
//  group             |  Tango::DevString	Scalar
//  shlvd_time        |  Tango::DevLong	Scalar
//  on_delay          |  Tango::DevLong	Scalar
//  off_delay         |  Tango::DevLong	Scalar
//  on_command        |  Tango::DevString	Scalar
//  off_command       |  Tango::DevString	Scalar
//  enabled           |  Tango::DevBoolean	Scalar
//  handler           |  Tango::DevString	Scalar
//  url               |  Tango::DevString	Scalar
//  default_archiver  |  Tango::DevBoolean	Scalar
//  archiver          |  Tango::DevString	Scalar
//  strategy          |  Tango::DevString	Scalar
//  alarmList         |  Tango::DevString	Spectrum  ( max = 10000)
//  alarmFrequency    |  Tango::DevDouble	Spectrum  ( max = 10000)
//  handlerStatus     |  Tango::DevString	Spectrum  ( max = 1000)
//================================================================

namespace AlarmManager_ns
{
/*----- PROTECTED REGION ID(AlarmManager::namespace_starting) ENABLED START -----*/

//	static initializations
//map<string, string> AlarmManager::domain_map;


typedef std::vector<string> Vec;
struct Contained
{
    Vec &_sequence;
    Vec _sequence2;
    Contained(Vec &vec) : _sequence(vec){
    	Vec _sequence_upper(vec);
    	for(Vec::iterator it = _sequence_upper.begin(); it!=_sequence_upper.end(); it++)
    	{
    		string result("");
   			string::size_type found;
   			string separator(":");
   			found = it->find_first_of(separator);
    		if(found != string::npos) {
    			if(found > 0) {
    				result = it->substr(0,found);
    			}
    		}
    		else if(it->length() > 0) {
    			result = *it;
    		}
    		std::transform(result.begin(), result.end(), result.begin(), (int(*)(int))toupper);
    		_sequence2.push_back(result);
    	}
    }
    bool operator()(string i) const
    {
		string result("");
		string::size_type found;
		string separator(":");
		found = i.find_first_of(separator);
		if(found != string::npos) {
			if(found > 0) {
				result = i.substr(0,found);
			}
		}
		else if(i.length() > 0) {
			result = i;
		}
    	std::transform(result.begin(), result.end(), result.begin(), (int(*)(int))toupper);
        return _sequence2.end() != std::find(_sequence2.begin(), _sequence2.end(), result);
    }
};

struct AlarmStringUtils
{
	static map<string, string> domain_map;
    static map<Tango::DevState,string> tango_states;
	static void string_explode(string str, const string& separator, vector<string>& results);
	static void string_vector2map(const vector<string> &str, const string &separator, unordered_map<string,string> &results);
	static void fix_tango_host(string &attr);
	static void add_domain(string &str);
	static string get_only_attr_name(const string &str);
	static string get_only_tango_host(const string &str);
	static string remove_domain(const string &str);
	static void split_tag_handler(const string &name, string &handler, string &tag);
};
//	static initialization
map<string, string> AlarmStringUtils::domain_map;
map<Tango::DevState, string> AlarmStringUtils::tango_states ={ 
	{ Tango::ON, "ON" },
	{ Tango::OFF, "OFF" },
	{ Tango::CLOSE, "CLOSE" },
	{ Tango::OPEN, "OPEN" },
	{ Tango::INSERT, "INSERT" },
	{ Tango::EXTRACT, "EXTRACT" },
	{ Tango::MOVING, "MOVING" },
	{ Tango::STANDBY, "STANDBY" },
	{ Tango::FAULT, "FAULT" },
	{ Tango::INIT, "INIT" },
	{ Tango::RUNNING, "RUNNING" },
	{ Tango::ALARM, "ALARM" },
	{ Tango::DISABLE, "DISABLE" },
	{ Tango::UNKNOWN, "UNKNOWN" }
}; 

void AlarmStringUtils::string_explode(string str, const string& separator, vector<string>& results)
{
	auto found = str.find_first_of(separator);
	while(found != string::npos)
	{
		if(found > 0)
		{
			results.push_back(str.substr(0,found));
		}
		str = str.substr(found+1);
		found = str.find_first_of(separator);
	}
	if(str.length() > 0) {
		results.push_back(str);
	}
}

void AlarmStringUtils::string_vector2map(const vector<string> &str, const string &separator, unordered_map<string,string> &results)
{
	for(const auto &it : str)
	{
		auto found_eq = it.find_first_of(separator);
		if(found_eq != string::npos && found_eq > 0)
		{
			results.insert(make_pair(it.substr(0,found_eq),it.substr(found_eq+1)));
		}
	}
}

void AlarmStringUtils::fix_tango_host(string &attr)
{
	std::transform(attr.begin(), attr.end(), attr.begin(), (int(*)(int))tolower);		//transform to lowercase
	string::size_type	start = attr.find("tango://");
	//if not fqdn, add TANGO_HOST
	if (start == string::npos)
	{
		//TODO: get from device/class/global property
		char	*env = getenv("TANGO_HOST");
		if (env==NULL)
		{
			return;
		}
		else
		{
			string	s(env);
			add_domain(s);
			attr = string("tango://") + s + "/" + attr;
			return;
		}
	}
	string facility = get_only_tango_host(attr);
	add_domain(facility);
	string attr_name = get_only_attr_name(attr);
	attr = string("tango://")+ facility + string("/") + attr_name;
}

void AlarmStringUtils::add_domain(string &str)
{
	string::size_type	end1 = str.find(".");
	if (end1 == string::npos)
	{
		//get host name without tango://
		string::size_type	start = str.find("tango://");
		if (start == string::npos)
		{
			start = 0;
		}
		else
		{
			start = 8;	//tango:// len
		}
		string::size_type	end2 = str.find(":", start);

		string th = str.substr(start, end2);
		string with_domain = str;

		map<string,string>::iterator it_domain = domain_map.find(th);
		if(it_domain != domain_map.end())
		{
			with_domain = it_domain->second;
			//cout << __func__ <<": found domain in map -> " << with_domain<<endl;
			str = with_domain;
			return;
		}

		struct addrinfo hints;
//		hints.ai_family = AF_INET; // use AF_INET6 to force IPv6
//		hints.ai_flags = AI_CANONNAME|AI_CANONIDN;
		memset(&hints, 0, sizeof hints);
		hints.ai_family = AF_UNSPEC; /*either IPV4 or IPV6*/
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_flags = AI_CANONNAME;
		struct addrinfo *result;
		int ret = getaddrinfo(th.c_str(), NULL, &hints, &result);
		if (ret != 0)
		{
			cout << __func__<< ": getaddrinfo error='" << gai_strerror(ret)<<"' while looking for " << th<<endl;
			return;
		}
		if(result == NULL)
		{
			cout << __func__ << ": getaddrinfo did not return domain information for " 
			     << th << " (result == NULL)" << endl;
			return;
		}
		if (result->ai_canonname == NULL)
		{
			cout << __func__ << ": getaddrinfo did not return domain information for " 
			     << th << " (result->ai_canonname == NULL)" << endl;
			freeaddrinfo(result);
			return;
		}
		with_domain = string(result->ai_canonname) + str.substr(end2);
		//cout << __func__ <<": found domain -> " << with_domain<<endl;
		domain_map.insert(make_pair(th, with_domain));
		freeaddrinfo(result); // all done with this structure
		str = with_domain;
		return;
	}
	else
	{
		return;
	}
}

string AlarmStringUtils::get_only_attr_name(const string &str)
{
	string::size_type	start = str.find("tango://");
	if (start == string::npos)
		return str;
	else
	{
		start += 8; //	"tango://" length
		start = str.find('/', start);
		start++;
		string	tagname = str.substr(start);
		return tagname;
	}
}

string AlarmStringUtils::get_only_tango_host(const string &str)
{
	string::size_type	start = str.find("tango://");
	if (start == string::npos)
	{
		return "unknown";
	}
	else
	{
		start += 8; //	"tango://" length
		string::size_type	end = str.find('/', start);
		string th = str.substr(start, end-start);
		return th;
	}
}

string AlarmStringUtils::remove_domain(const string &str)
{
	string::size_type	end1 = str.find(".");
	if (end1 == string::npos)
	{
		return str;
	}
	else
	{
		string::size_type	start = str.find("tango://");
		if (start == string::npos)
		{
			start = 0;
		}
		else
		{
			start = 8;	//tango:// len
		}
		string::size_type	end2 = str.find(":", start);
		if(end1 > end2)	//'.' not in the tango host part
			return str;
		string th = str.substr(0, end1);
		th += str.substr(end2, str.size()-end2);
		return th;
	}
}

void AlarmStringUtils::split_tag_handler(const string &name, string &handler, string &tag)
{
	auto pos = name.find_last_of("/");
	if (pos != string::npos)
	{
		handler=name.substr(0,pos);
		tag=name.substr(pos+1,name.size()-pos-1);
	}
}

//return false if str1 >= str2
bool compare_tango_names(string str1, string str2)
{
	//cout << __func__<< ": entering with '" << str1<<"' - '" << str2<<"'" << endl;
	if(str1 == str2)
	{
		//cout << __func__<< ": EQUAL 1 -> '" << str1<<"'=='" << str2<<"'" << endl;
		return false;
	}
	AlarmStringUtils::fix_tango_host(str1);
	AlarmStringUtils::fix_tango_host(str2);
	if(str1 == str2)
	{
		//cout << __func__<< ": EQUAL 2 -> '" << str1<<"'=='" << str2<<"'" << endl;
		return false;
	}
	string str1_nd = AlarmStringUtils::remove_domain(str1);
	string str2_nd = AlarmStringUtils::remove_domain(str2);
	if(str1_nd == str2_nd)
	{
		//cout << __func__<< ": EQUAL 3 -> '" << str1_nd<<"'=='" << str2_nd<<"'" << endl;
		return false;
	}
	bool result=str1_nd<str2_nd;
	//cout << __func__<< ": DIFFERENTS -> '" << str1_nd<< (result ? "'<'" : "'>'") << str2_nd<<"' result="<<result << endl;
	return result;
}

template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args)
{
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

/*----- PROTECTED REGION END -----*/	//	AlarmManager::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::AlarmManager()
 *	Description : Constructors for a Tango device
 *                implementing the classAlarmManager
 */
//--------------------------------------------------------
AlarmManager::AlarmManager(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(AlarmManager::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::constructor_1
}
//--------------------------------------------------------
AlarmManager::AlarmManager(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(AlarmManager::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::constructor_2
}
//--------------------------------------------------------
AlarmManager::AlarmManager(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(AlarmManager::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void AlarmManager::delete_device()
{
	DEBUG_STREAM << "AlarmManager::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::delete_device
	delete[] attr_tag_read;
	delete[] attr_formula_read;
	delete[] attr_message_read;
	delete[] attr_priority_read;
	delete[] attr_group_read;
	delete[] attr_shlvd_time_read;
	delete[] attr_on_delay_read;
	delete[] attr_off_delay_read;
	delete[] attr_on_command_read;
	delete[] attr_off_command_read;
	delete[] attr_enabled_read;
	delete[] attr_handler_read;
	delete[] attr_url_read;
	delete[] attr_default_archiver_read;
	delete[] attr_archiver_read;
	delete[] attr_strategy_read;
	delete[] attr_alarmList_read;
	delete[] attr_alarmFrequency_read;
	delete[] attr_handlerStatus_read;
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void AlarmManager::init_device()
{
	DEBUG_STREAM << "AlarmManager::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	attr_alarmList_read = NULL;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_tag_read = new Tango::DevString[1];
	attr_formula_read = new Tango::DevString[1];
	attr_message_read = new Tango::DevString[1];
	attr_priority_read = new Tango::DevString[1];
	attr_group_read = new Tango::DevString[1];
	attr_shlvd_time_read = new Tango::DevLong[1];
	attr_on_delay_read = new Tango::DevLong[1];
	attr_off_delay_read = new Tango::DevLong[1];
	attr_on_command_read = new Tango::DevString[1];
	attr_off_command_read = new Tango::DevString[1];
	attr_enabled_read = new Tango::DevBoolean[1];
	attr_handler_read = new Tango::DevString[1];
	attr_url_read = new Tango::DevString[1];
	attr_default_archiver_read = new Tango::DevBoolean[1];
	attr_archiver_read = new Tango::DevString[1];
	attr_strategy_read = new Tango::DevString[1];
	attr_alarmList_read = new Tango::DevString[10000];
	attr_alarmFrequency_read = new Tango::DevDouble[10000];
	attr_handlerStatus_read = new Tango::DevString[1000];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(AlarmManager::init_device) ENABLED START -----*/
	
	//	Initialize device
	*attr_tag_read = CORBA::string_dup("");
	*attr_formula_read = CORBA::string_dup("");
	*attr_message_read = CORBA::string_dup("");
	*attr_priority_read = CORBA::string_dup("");
	*attr_group_read = CORBA::string_dup("");
	*attr_shlvd_time_read = -1;
	*attr_on_delay_read = 0;
	*attr_off_delay_read = 0;
	*attr_on_command_read = CORBA::string_dup("");
	*attr_off_command_read = CORBA::string_dup("");
	*attr_enabled_read = true;
	*attr_handler_read = CORBA::string_dup("");
	*attr_url_read = CORBA::string_dup("");
	*attr_archiver_read = CORBA::string_dup("");
	*attr_strategy_read = CORBA::string_dup("");

	for(auto it : propertyList)
	{
		vector<string> prop_name;
		AlarmStringUtils::string_explode(it, "/", prop_name);
		if(prop_name.size() != 2)
		{
			DEBUG_STREAM << __func__ << ": BAD property " << it << " size=" << prop_name.size();
			continue;
		}
		vector<string> hlist;
		auto db = make_unique<Tango::Database>();
		try
		{
			Tango::DbData db_data;
			db_data.push_back((Tango::DbDatum(prop_name[1])));
			db->get_property(prop_name[0],db_data);
			db_data[0] >> hlist;
		}catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << __FUNCTION__ << " Error reading Database property='" << e.errors[0].desc << "'";
		}
		for(auto hit : hlist)
		{
			if (std::find(handlerList.begin(), handlerList.end(), hit) == handlerList.end())
			{
				handlerList.push_back(hit);
			}
		}
	}
	handler_t tmp;
	for(auto it : handlerList)
	{
		try
		{
			tmp.dp = std::unique_ptr<Tango::DeviceProxy>(new Tango::DeviceProxy(it));
		}
		catch(Tango::DevFailed &e)
		{
			tmp.dp = std::unique_ptr<Tango::DeviceProxy>(nullptr);
		}
		string hndlname(it);
		AlarmStringUtils::fix_tango_host(hndlname);
		DEBUG_STREAM << __func__<<": adding handler:"<<hndlname;
		handler_list_fix.push_back(hndlname);
		handlerMap.insert(make_pair(hndlname,std::move(tmp)));
	}
	try
	{
		hdbpp = std::unique_ptr<Tango::DeviceProxy>(new Tango::DeviceProxy(defaultArchiver));
	}
	catch(Tango::DevFailed &e)
	{
		hdbpp = std::unique_ptr<Tango::DeviceProxy>(nullptr);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::init_device
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void AlarmManager::get_device_property()
{
	/*----- PROTECTED REGION ID(AlarmManager::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("HandlerList"));
	dev_prop.push_back(Tango::DbDatum("MaxSearchSize"));
	dev_prop.push_back(Tango::DbDatum("PropertyList"));
	dev_prop.push_back(Tango::DbDatum("DefaultArchiver"));
	dev_prop.push_back(Tango::DbDatum("DefaultStrategy"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on AlarmManagerClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		AlarmManagerClass	*ds_class =
			(static_cast<AlarmManagerClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize HandlerList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  handlerList;
		else {
			//	Try to initialize HandlerList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  handlerList;
		}
		//	And try to extract HandlerList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  handlerList;

		//	Try to initialize MaxSearchSize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxSearchSize;
		else {
			//	Try to initialize MaxSearchSize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxSearchSize;
		}
		//	And try to extract MaxSearchSize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxSearchSize;

		//	Try to initialize PropertyList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  propertyList;
		else {
			//	Try to initialize PropertyList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  propertyList;
		}
		//	And try to extract PropertyList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  propertyList;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize DefaultArchiver from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultArchiver;
		else {
			//	Try to initialize DefaultArchiver from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultArchiver;
		}
		//	And try to extract DefaultArchiver value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultArchiver;

		//	Try to initialize DefaultStrategy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultStrategy;
		else {
			//	Try to initialize DefaultStrategy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultStrategy;
		}
		//	And try to extract DefaultStrategy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultStrategy;

	}

	/*----- PROTECTED REGION ID(AlarmManager::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmManager::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void AlarmManager::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(AlarmManager::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	AlarmManager::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : AlarmManager::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void AlarmManager::always_executed_hook()
{
	DEBUG_STREAM << "AlarmManager::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"AlarmManager::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(AlarmManager::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	timespec now;
	clock_gettime(CLOCK_MONOTONIC,&now);
	if((now.tv_sec - last_stat.tv_sec + (double)(now.tv_nsec - last_stat.tv_nsec)/1e9) < 2.0)
	{
		return;
	}
	clock_gettime(CLOCK_MONOTONIC,&last_stat);
	bool handler_fault = false;
	for(auto itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		if(itmap->second.dp.get() == nullptr)
		{
			DEBUG_STREAM << __func__ << ": reconnecting to " << itmap->first;
			try
			{
				itmap->second.dp = std::unique_ptr<Tango::DeviceProxy>(new Tango::DeviceProxy(itmap->first.c_str()));
			}
			catch(Tango::DevFailed &e)
			{
				itmap->second.dp = std::unique_ptr<Tango::DeviceProxy>(nullptr);
			}
		}
		else
        {
			try
			{
				if (!itmap->second.dp->ping())
				{
					INFO_STREAM << "AlarmManager::always_executed_hook() handler " << itmap->first << " PING NOK" << endl;
					handler_fault = true;
				}
			}
			catch(Tango::DevFailed &e)
			{
				INFO_STREAM << "AlarmManager::always_executed_hook() handler " << itmap->first << " Exception" << endl;
				handler_fault = true;
			}
        }
	}
	if(handler_fault)
	{
		DEBUG_STREAM << __func__<<": setting state FAULT "<<endl;
		set_state(Tango::FAULT);
		set_status("At least one handler Not Responding");
		return;
	}
	Tango::DevState stat = Tango::ON;
	string status("Everything is OK");
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DevState stat_arch;
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("State");
				if(!Dout.is_empty())
				{
					Dout >> stat_arch;
					if(stat_arch != Tango::ON)
					{
						stat = Tango::ALARM;
						status = string("At least one alarm present");
						break;
					}
				}
			}
			else
			{
				stat = Tango::FAULT;
				string status("At least one handler Not Responding");
				break;
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read State from " << itmap->first;
			stat = Tango::FAULT;
			status = string("At least one handler Not Responding");
			break;
		}
	}
	if(get_state() != stat)
	{
		set_state(stat);
		set_status(status);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void AlarmManager::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "AlarmManager::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : AlarmManager::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void AlarmManager::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "AlarmManager::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute tag related method
 *	Description: Alarm tag
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_tag(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_tag(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_tag) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_tag_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_tag
}
//--------------------------------------------------------
/**
 *	Write attribute tag related method
 *	Description: Alarm tag
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_tag(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_tag(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_tag) ENABLED START -----*/
	string name(w_val);
	//remove white spaces:
	name.erase (std::remove (name.begin(), name.end(), ' '), name.end());
	string handler, tag;
	find_handler_tag(name, handler, tag);
	DEBUG_STREAM << __func__ << ": found handler '"<< handler <<"' for alarm '"<<tag<<"'"<<endl;
	*attr_tag_read = CORBA::string_dup(tag.c_str()); //TODO: check if already existing
	*attr_handler_read = CORBA::string_dup(handler.c_str());
	auto itmapnew = handlerMap.find(handler);
	if(itmapnew != handlerMap.end())
	{
		Tango::DeviceData Din, Dout;
		vector<string> cmd_param;
		cmd_param.push_back(tag);
		cmd_param.push_back("enabled");
		cmd_param.push_back("formula");
		cmd_param.push_back("group");
		cmd_param.push_back("message");
		cmd_param.push_back("off_command");
		cmd_param.push_back("off_delay");
		cmd_param.push_back("on_command");
		cmd_param.push_back("on_delay");
		cmd_param.push_back("priority");
		cmd_param.push_back("shlvd_time");
		cmd_param.push_back("url");
		Din << cmd_param;
		Dout = itmapnew->second.dp->command_inout("GetAlarmInfo",Din);
		vector<string> resp;
		Dout >> resp;
		unordered_map<string,string> conf;
		AlarmStringUtils::string_vector2map(resp, "=", conf);
		try
		{
			*attr_enabled_read = stoi(conf.at("enabled"));
			*attr_formula_read = CORBA::string_dup(conf.at("formula").c_str());
			//*attr_formula_read = CORBA::string_dup(formula.c_str());
			*attr_group_read = CORBA::string_dup(conf.at("group").c_str());
			string trimmsg = conf.at("message");
			if(trimmsg.size()>=2)
			{
				if(trimmsg.front()=='"' && trimmsg.back()=='"')
				{
					trimmsg.pop_back();
					trimmsg.erase(trimmsg.begin());
				}
			}
			*attr_message_read = CORBA::string_dup(trimmsg.c_str());
			*attr_off_command_read = CORBA::string_dup(conf.at("off_command").c_str());
			*attr_on_command_read = CORBA::string_dup(conf.at("on_command").c_str());
			*attr_priority_read = CORBA::string_dup(conf.at("priority").c_str());
			*attr_url_read = CORBA::string_dup(conf.at("url").c_str());
			*attr_off_delay_read = stoi(conf.at("off_delay"));
			*attr_on_delay_read = stoi(conf.at("on_delay"));
			*attr_shlvd_time_read = stoi(conf.at("shlvd_time"));
		}
		catch(const std::out_of_range& e)
		{
			stringstream tmp;
			tmp << "Configuration parsing error: " << e.what();
			DEBUG_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception("Configuration Error",tmp.str(),__func__);
		}
	}
	if(hdbpp.get() != nullptr)
	{
		Tango::DeviceData Din;
		string attr(handler+"/"+tag);
		Din << attr;
		string strategy;
		try
		{
			hdbpp->command_inout("GetAttributeStrategy",Din) >> strategy;
			*attr_archiver_read = Tango::string_dup(defaultArchiver.c_str());
			*attr_strategy_read = Tango::string_dup(defaultStrategy.c_str());
		}
		catch(Tango::DevFailed& e)
		{
			*attr_archiver_read = Tango::string_dup("");
			*attr_strategy_read = Tango::string_dup("");
		}
	}
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_tag
}
//--------------------------------------------------------
/**
 *	Read attribute formula related method
 *	Description: Alarm formula
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_formula(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_formula(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_formula) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_formula_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_formula
}
//--------------------------------------------------------
/**
 *	Write attribute formula related method
 *	Description: Alarm formula
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_formula(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_formula(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_formula) ENABLED START -----*/
	string formula(w_val);
	//remove white spaces:
	formula.erase (std::remove (formula.begin(), formula.end(), ' '), formula.end());
	*attr_formula_read = Tango::string_dup(formula.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_formula
}
//--------------------------------------------------------
/**
 *	Read attribute message related method
 *	Description: Alarm message
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_message(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_message(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_message) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_message_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_message
}
//--------------------------------------------------------
/**
 *	Write attribute message related method
 *	Description: Alarm message
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_message(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_message(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_message) ENABLED START -----*/
	string msg(w_val);//TODO: escape ?
	*attr_message_read = CORBA::string_dup(msg.c_str());	
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_message
}
//--------------------------------------------------------
/**
 *	Read attribute priority related method
 *	Description: Alarm priority
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_priority(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_priority(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_priority) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_priority_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_priority
}
//--------------------------------------------------------
/**
 *	Write attribute priority related method
 *	Description: Alarm priority
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_priority(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_priority(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_priority) ENABLED START -----*/
	string priority(w_val);
	*attr_priority_read = CORBA::string_dup(priority.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_priority
}
//--------------------------------------------------------
/**
 *	Read attribute group related method
 *	Description: Alarm group
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_group(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_group(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_group) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_group_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_group
}
//--------------------------------------------------------
/**
 *	Write attribute group related method
 *	Description: Alarm group
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_group(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_group(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_group) ENABLED START -----*/
	string group(w_val);
	*attr_group_read = CORBA::string_dup(group.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_group
}
//--------------------------------------------------------
/**
 *	Read attribute shlvd_time related method
 *	Description: Alarm shelved time in minutes, -1 if disabled
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_shlvd_time(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_shlvd_time(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_shlvd_time) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_shlvd_time_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_shlvd_time
}
//--------------------------------------------------------
/**
 *	Write attribute shlvd_time related method
 *	Description: Alarm shelved time in minutes, -1 if disabled
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_shlvd_time(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_shlvd_time(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_shlvd_time) ENABLED START -----*/
	*attr_shlvd_time_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_shlvd_time
}
//--------------------------------------------------------
/**
 *	Read attribute on_delay related method
 *	Description: Alarm delay time in seconds before becoming active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_on_delay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_on_delay(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_on_delay) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_on_delay_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_on_delay
}
//--------------------------------------------------------
/**
 *	Write attribute on_delay related method
 *	Description: Alarm delay time in seconds before becoming active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_on_delay(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_on_delay(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_on_delay) ENABLED START -----*/
	*attr_on_delay_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_on_delay
}
//--------------------------------------------------------
/**
 *	Read attribute off_delay related method
 *	Description: Alarm delay time in seconds before becoming non active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_off_delay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_off_delay(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_off_delay) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_off_delay_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_off_delay
}
//--------------------------------------------------------
/**
 *	Write attribute off_delay related method
 *	Description: Alarm delay time in seconds before becoming non active
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_off_delay(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_off_delay(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_off_delay) ENABLED START -----*/
	*attr_off_delay_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_off_delay
}
//--------------------------------------------------------
/**
 *	Read attribute on_command related method
 *	Description: Alarm command executed when becoming active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_on_command(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_on_command(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_on_command) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_on_command_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_on_command
}
//--------------------------------------------------------
/**
 *	Write attribute on_command related method
 *	Description: Alarm command executed when becoming active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_on_command(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_on_command(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_on_command) ENABLED START -----*/
	string on_command(w_val);
	*attr_on_command_read = CORBA::string_dup(on_command.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_on_command
}
//--------------------------------------------------------
/**
 *	Read attribute off_command related method
 *	Description: Alarm command executed when becoming non active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_off_command(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_off_command(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_off_command) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_off_command_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_off_command
}
//--------------------------------------------------------
/**
 *	Write attribute off_command related method
 *	Description: Alarm command executed when becoming non active
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_off_command(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_off_command(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_off_command) ENABLED START -----*/
	string off_command(w_val);
	*attr_off_command_read = CORBA::string_dup(off_command.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_off_command
}
//--------------------------------------------------------
/**
 *	Read attribute enabled related method
 *	Description: Alarm enabled
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_enabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_enabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_enabled) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_enabled_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_enabled
}
//--------------------------------------------------------
/**
 *	Write attribute enabled related method
 *	Description: Alarm enabled
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_enabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_enabled(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_enabled) ENABLED START -----*/
	*attr_enabled_read = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_enabled
}
//--------------------------------------------------------
/**
 *	Read attribute handler related method
 *	Description: Alarm Handler device
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_handler(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_handler(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_handler) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_handler_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_handler
}
//--------------------------------------------------------
/**
 *	Write attribute handler related method
 *	Description: Alarm Handler device
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_handler(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_handler(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_handler) ENABLED START -----*/
	string handler(w_val);
	*attr_handler_read = CORBA::string_dup(handler.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_handler
}
//--------------------------------------------------------
/**
 *	Read attribute url related method
 *	Description: Alarm url
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_url(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_url(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_url) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_url_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_url
}
//--------------------------------------------------------
/**
 *	Write attribute url related method
 *	Description: Alarm url
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_url(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_url(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_url) ENABLED START -----*/
	string url(w_val);
	*attr_url_read = CORBA::string_dup(url.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_url
}
//--------------------------------------------------------
/**
 *	Read attribute default_archiver related method
 *	Description: Use DefaultArchiver device property
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_default_archiver(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_default_archiver(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_default_archiver) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_default_archiver_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_default_archiver
}
//--------------------------------------------------------
/**
 *	Write attribute default_archiver related method
 *	Description: Use DefaultArchiver device property
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_default_archiver(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_default_archiver(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_default_archiver) ENABLED START -----*/
	*attr_default_archiver_read = w_val;
	
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_default_archiver
}
//--------------------------------------------------------
/**
 *	Read attribute archiver related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_archiver(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_archiver(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_archiver) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_archiver_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_archiver
}
//--------------------------------------------------------
/**
 *	Write attribute archiver related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_archiver(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_archiver(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_archiver) ENABLED START -----*/
	string archiver(w_val);
	*attr_archiver_read = CORBA::string_dup(archiver.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_archiver
}
//--------------------------------------------------------
/**
 *	Read attribute strategy related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::read_strategy(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_strategy(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_strategy) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_strategy_read);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_strategy
}
//--------------------------------------------------------
/**
 *	Write attribute strategy related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void AlarmManager::write_strategy(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AlarmManager::write_strategy(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(AlarmManager::write_strategy) ENABLED START -----*/
	string strategy(w_val);
	*attr_strategy_read = CORBA::string_dup(strategy.c_str());	
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::write_strategy
}
//--------------------------------------------------------
/**
 *	Read attribute alarmList related method
 *	Description: List of all alarms
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void AlarmManager::read_alarmList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_alarmList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_alarmList) ENABLED START -----*/
	vector<string> complete_list;
	DEBUG_STREAM << __func__ << ": complete list -> size=" << complete_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmList");
				if(!Dout.is_empty())
					Dout >> itmap->second.alm_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
				itmap->second.alm_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
			itmap->second.alm_list.clear();
		}
		DEBUG_STREAM << __func__ << ": partial list -> size=" << itmap->second.alm_list.size() << endl;
		//complete_list.insert(complete_list.end(),itmap->second.alm_list.begin(), itmap->second.alm_list.end());
		for(auto it : itmap->second.alm_list)
		{
			complete_list.push_back(itmap->first+"/"+it);
		}
		DEBUG_STREAM << __func__ << ": building complete list -> size=" << complete_list.size() << endl;
	}
	size_t i=0;
	for(auto it : complete_list)
	{
		attr_alarmList_read[i++] = CORBA::string_dup(it.c_str());
	}
	//	Set the attribute value
	attr.set_value(attr_alarmList_read, complete_list.size());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_alarmList
}
//--------------------------------------------------------
/**
 *	Read attribute alarmFrequency related method
 *	Description: List of frequency of evaluation of all alarms
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void AlarmManager::read_alarmFrequency(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_alarmFrequency(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_alarmFrequency) ENABLED START -----*/
	vector<double> freq_list;
	DEBUG_STREAM << __func__ << ": complete list -> size=" << freq_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmFrequency");
				if(!Dout.is_empty())
					Dout >> itmap->second.freq_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmFrequency from " << itmap->first;
				itmap->second.freq_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmFrequency from " << itmap->first;
			itmap->second.freq_list.clear();
		}
		DEBUG_STREAM << __func__ << ": partial list -> size=" << itmap->second.freq_list.size() << endl;
		freq_list.insert(freq_list.end(),itmap->second.freq_list.begin(), itmap->second.freq_list.end());
		DEBUG_STREAM << __func__ << ": building complete list -> size=" << freq_list.size() << endl;
	}
	size_t i=0;
	for(auto it : freq_list)
	{
		attr_alarmFrequency_read[i++] = it;
	}
	//	Set the attribute value
	attr.set_value(attr_alarmFrequency_read, freq_list.size());
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_alarmFrequency
}
//--------------------------------------------------------
/**
 *	Read attribute handlerStatus related method
 *	Description: List of:
 *               Handler Device Name = Tango State
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void AlarmManager::read_handlerStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AlarmManager::read_handlerStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(AlarmManager::read_handlerStatus) ENABLED START -----*/
	size_t i=0;
	for(auto it = handlerMap.begin(); it != handlerMap.end(); it++)
	{
		string hstatus=it->first+": ";
		Tango::DevState hstate;
		try
		{
			if(it->second.dp)
			{
				it->second.dp->read_attribute("State") >> hstate;
				hstatus+=AlarmStringUtils::tango_states.at(hstate);
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read State from " << it->first;
			hstatus+=e.errors[0].desc;
		}
		catch(const std::out_of_range& e)
		{
			INFO_STREAM << "Unknown state: " << hstate;
			hstatus+=to_string(static_cast<int>(hstate));
		}
		attr_handlerStatus_read[i++] = CORBA::string_dup(hstatus.c_str());
	}
	//	Set the attribute value
	attr.set_value(attr_handlerStatus_read, i);
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::read_handlerStatus
}

//--------------------------------------------------------
/**
 *	Method      : AlarmManager::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void AlarmManager::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(AlarmManager::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Load related method
 *	Description: Load alarm taking configuration from attributes
 *
 */
//--------------------------------------------------------
void AlarmManager::load()
{
	DEBUG_STREAM << "AlarmManager::Load()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::load) ENABLED START -----*/
	
	//	Add your own code
	string tagname(*attr_tag_read);
	string hndlrname = find_handler(tagname);

	auto itmapnew = handlerMap.find(hndlrname);
	if(itmapnew != handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' already configured in '"<<hndlrname<<"'";
		Tango::Except::throw_exception( \
					(const char*)"Already configured", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	hndlrname=string(*attr_handler_read);
	itmapnew = handlerMap.find(hndlrname);
	if(itmapnew == handlerMap.end())
	{
		stringstream tmp;
		tmp << "handler '" << hndlrname << "' not found";
		Tango::Except::throw_exception( \
					(const char*)"handler not found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	//------4: Assign to existing EventSubscriber--------------------------
	if(itmapnew->second.dp)
	{
		string load_str="tag="+tagname+";formula="+string(*attr_formula_read)+";message="+string(*attr_message_read)+
		";priority="+string(*attr_priority_read)+";group="+string(*attr_group_read)+";shlvd_time="+to_string(*attr_shlvd_time_read)+
		";on_delay="+to_string(*attr_on_delay_read)+";off_delay="+to_string(*attr_off_delay_read)+
		";on_command="+string(*attr_on_command_read)+";off_command="+string(*attr_off_command_read)+
		";url="+string(*attr_url_read)+";enabled="+to_string(*attr_enabled_read);
		Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
		Tango::DeviceData Din;
		Din << load_argin;
		itmapnew->second.dp->command_inout("Load",Din);
	}
	else
	{
		stringstream tmp;
		tmp << "handler " << itmapnew->first << " Not Responding";
		Tango::Except::throw_exception( \
					(const char*)"Error", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::load
}
//--------------------------------------------------------
/**
 *	Command Remove related method
 *	Description: 
 *
 *	@param argin tagname
 */
//--------------------------------------------------------
void AlarmManager::remove(Tango::DevString argin)
{
	DEBUG_STREAM << "AlarmManager::Remove()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::remove) ENABLED START -----*/
	
	//	Add your own code
	string name(argin);
	string handler, tag;
	find_handler_tag(name, handler, tag);
	DEBUG_STREAM << __func__ << ": found handler '"<< handler <<"' for alarm '"<<tag<<"'"<<endl;
	auto itmap = handlerMap.find(handler);
	if(itmap == handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tag << "' handler '" << handler << "' NOT FOUND";
		Tango::Except::throw_exception( \
					(const char*)"NOT FOUND", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}
	if(itmap->second.dp)
	{
		Tango::DeviceData Din,Din2;
		vector<string> vtag;
		vtag.push_back(tag);
		Din << tag;
		Din2 << vtag;
		itmap->second.dp->command_inout("Ack",Din2);
		itmap->second.dp->command_inout("Remove",Din);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::remove
}
//--------------------------------------------------------
/**
 *	Command Modify related method
 *	Description: Modify alarm taking configuration from attributes
 *
 */
//--------------------------------------------------------
void AlarmManager::modify()
{
	DEBUG_STREAM << "AlarmManager::Modify()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::modify) ENABLED START -----*/
	
	//	Add your own code
	string tagname(*attr_tag_read);
	string hndlrname = find_handler(tagname);

	auto itmapold = handlerMap.find(hndlrname);
	if(itmapold == handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' Not Found";
		Tango::Except::throw_exception( \
					(const char*)"Not Found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	string hndlrnamenew=string(*attr_handler_read);
	auto itmapnew = handlerMap.find(hndlrnamenew);
	if(itmapnew == handlerMap.end())
	{
		stringstream tmp;
		tmp << "handler '" << hndlrname << "' not found";
		Tango::Except::throw_exception( \
					(const char*)"handler not found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}
	DEBUG_STREAM << __func__ << ": Tag="<<tagname<<" Handler configured="<<hndlrname<<" requested="<<hndlrnamenew;
	if(compare_tango_names(hndlrnamenew, hndlrname) == false) //modify in same handler
	{
		DEBUG_STREAM << __func__ << ": Tag="<<tagname<<" Same Handler="<<hndlrname<<" -> Modify";
		if(itmapold->second.dp)
		{
			string load_str="tag="+tagname+";formula="+string(*attr_formula_read)+";message="+string(*attr_message_read)+
			";priority="+string(*attr_priority_read)+";group="+string(*attr_group_read)+
			";shlvd_time="+to_string(*attr_shlvd_time_read)+";on_delay="+to_string(*attr_on_delay_read)+
			";off_delay="+to_string(*attr_off_delay_read)+";on_command="+string(*attr_on_command_read)+
			";off_command="+string(*attr_off_command_read)+";url="+string(*attr_url_read)+";enabled="+to_string(*attr_enabled_read);
			Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
			Tango::DeviceData Din;
			Din << load_argin;
			itmapold->second.dp->command_inout("Modify",Din);
		}
		else
		{
			stringstream tmp;
			tmp << "handler " << itmapold->first << " Not Responding";
			Tango::Except::throw_exception( \
						(const char*)"Error", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
	}
	else	//changed handler
	{
		DEBUG_STREAM << __func__ << ": Tag="<<tagname<<" Changed Handler="<<hndlrnamenew<<" -> Load";
		if(itmapnew->second.dp)
		{
			string load_str="tag="+tagname+";formula="+string(*attr_formula_read)+";message="+string(*attr_message_read)+
			";priority="+string(*attr_priority_read)+";group="+string(*attr_group_read)+";shlvd_time="+to_string(*attr_shlvd_time_read)+
			";on_delay="+to_string(*attr_on_delay_read)+";off_delay="+to_string(*attr_off_delay_read)+";on_command="+
			string(*attr_on_command_read)+";off_command="+string(*attr_off_command_read)+";url="+string(*attr_url_read)+
			";enabled="+to_string(*attr_enabled_read);
			DEBUG_STREAM << __func__ << ": Loading:"<<load_str;
			Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
			Tango::DeviceData Din;
			Din << load_argin;
			itmapnew->second.dp->command_inout("Load",Din);
		}
		else
		{
			stringstream tmp;
			tmp << "handler " << itmapnew->first << " Not Responding";
			Tango::Except::throw_exception( \
						(const char*)"Error", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
		if(itmapold->second.dp)
		{
			DEBUG_STREAM << __func__ << ": Removing:"<<tagname;
			Tango::DeviceData Din,Din2;
			vector<string> vtag;
			vtag.push_back(tagname);
			Din << tagname;
			Din2 << vtag;
			itmapold->second.dp->command_inout("Ack",Din2);
			itmapold->second.dp->command_inout("Remove",Din);
		}
		else
		{
			stringstream tmp;
			tmp << "handler " << itmapold->first << " Not Responding";
			if(itmapnew->second.dp)
			{
				DEBUG_STREAM << __func__ << ": Old Handler="<<hndlrname<<" Not responding, Removing from new";
				Tango::DeviceData Din,Din2;
				vector<string> vtag;
				vtag.push_back(tagname);
				Din << tagname;
				Din2 << vtag;
				itmapnew->second.dp->command_inout("Ack",Din);
				itmapnew->second.dp->command_inout("Remove",Din);
			}
			Tango::Except::throw_exception( \
						(const char*)"Error", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::modify
}
//--------------------------------------------------------
/**
 *	Command GetAlarmInfo related method
 *	Description: Returns the complete attribute info as an array of key=value
 *
 *	@param argin Alarm name followed optionally by wanted key names
 *	@returns Complete attribute info as an array of key=value
 */
//--------------------------------------------------------
Tango::DevVarStringArray *AlarmManager::get_alarm_info(const Tango::DevVarStringArray *argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "AlarmManager::GetAlarmInfo()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::get_alarm_info) ENABLED START -----*/
	
	//	Add your own code
	vector<string> param;
	param << (*argin);
	if(param.size() < 1)
	{
		Tango::Except::throw_exception( \
			(const char*)"BAD PARAM", \
			(const char*)"Expected at least 1 parameter", \
			(const char*)__func__, Tango::ERR);
	}
	string name(param[0]);
	string handler, tag;
	find_handler_tag(name, handler, tag);
	DEBUG_STREAM << __func__ << ": found handler '"<< handler <<"' for alarm '"<<tag<<"'"<<endl;
	auto itmap = handlerMap.find(handler);
	if(itmap == handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tag << "' handler '" << handler << "' NOT FOUND";
		Tango::Except::throw_exception( \
					(const char*)"NOT FOUND", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	argout = new Tango::DevVarStringArray();
	if(itmap->second.dp)
	{
		Tango::DeviceData Din, Dout;
		Din << param;
		Dout = itmap->second.dp->command_inout("GetAlarmInfo",Din);
		vector<string> resp;
		Dout >> resp;
		argout->length(resp.size()+1);
		size_t i=0;
		for(auto it : resp)
		{
			(*argout)[i] = CORBA::string_dup(it.c_str());
			i++;	
		}
		string handler=string("handler=")+itmap->first;
		(*argout)[i] = CORBA::string_dup(handler.c_str());
	}
	else
	{
		argout->length(0);
	}
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::get_alarm_info
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SearchAlarmName related method
 *	Description: Return list of configured alarm names matching the filter string
 *
 *	@param argin String containing a filter for output, if empty or * return all alarms
 *	@returns Configured alarm names
 */
//--------------------------------------------------------
Tango::DevVarStringArray *AlarmManager::search_alarm_name(Tango::DevString argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "AlarmManager::SearchAlarmName()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::search_alarm_name) ENABLED START -----*/
	
	//	Add your own code
	attribute_search_list_str.clear();
	vector<string> complete_list;
	DEBUG_STREAM << "AlarmManager::SearchAlarm()  - 0 complete list -> size=" << complete_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmList");
				if(!Dout.is_empty())
					Dout >> itmap->second.alm_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
				itmap->second.alm_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
			itmap->second.alm_list.clear();
		}
		DEBUG_STREAM << "AlarmManager::SearchAlarm()  - partial list -> size=" << itmap->second.alm_list.size() << endl;
		//complete_list.insert(complete_list.end(),itmap->second.alm_list.begin(), itmap->second.alm_list.end());
		for(auto it : itmap->second.alm_list)
		{
			complete_list.push_back(itmap->first+"/"+it);
		}
		DEBUG_STREAM << "AlarmManager::SearchAlarm()  - building complete list -> size=" << complete_list.size() << endl;
	}


	string filter(argin);
	size_t found;
	for(vector<string>::iterator it = complete_list.begin(); it != complete_list.end(); it++)
	{
		found = 0;
		if(filter.length() != 0)
		{
			found = it->find(filter);
		}
		if((filter.length() == 0) || (found != string::npos))
		{
			attribute_search_list_str.push_back(*it);
			DEBUG_STREAM << "AlarmManager::SearchAlarm()  - found: " << *it << endl;
			if(attribute_search_list_str.size() >= maxSearchSize)
				break;
		}
	}
	DEBUG_STREAM << "AlarmManager::SearchAlarm()  - found list -> size=" << attribute_search_list_str.size() << endl;

	argout = new Tango::DevVarStringArray();
	argout->length(attribute_search_list_str.size());
	int i = 0;
	for (vector<string>::iterator it= attribute_search_list_str.begin(); it != attribute_search_list_str.end(); it++)
	{
		DEBUG_STREAM << "AlarmManager::SearchAlarm()  - result list -> copying=" << *it << endl;
		(*argout)[i] = CORBA::string_dup(it->c_str());
		i++;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::search_alarm_name
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReLoadAll related method
 *	Description: Reload all alarms from attribute properties
 *
 */
//--------------------------------------------------------
void AlarmManager::re_load_all()
{
	DEBUG_STREAM << "AlarmManager::ReLoadAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::re_load_all) ENABLED START -----*/
	
	//	Add your own code
	for(handler_map_t::iterator it = handlerMap.begin(); it != handlerMap.end(); it++)
	{
		if(it->second.dp)
			it->second.dp->command_inout("ReLoadAll");
		else
			INFO_STREAM << __func__ << ": unable to ReLoadAll on " << it->first;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::re_load_all
}
//--------------------------------------------------------
/**
 *	Command ResetStatistics related method
 *	Description: Reset statistics
 *
 */
//--------------------------------------------------------
void AlarmManager::reset_statistics()
{
	DEBUG_STREAM << "AlarmManager::ResetStatistics()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::reset_statistics) ENABLED START -----*/
	
	//	Add your own code
	for(handler_map_t::iterator it = handlerMap.begin(); it != handlerMap.end(); it++)
	{
		if(it->second.dp)
			it->second.dp->command_inout("ResetStatistics");
		else
			INFO_STREAM << __func__ << ": unable to ResetStatistics on " << it->first;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::reset_statistics
}
//--------------------------------------------------------
/**
 *	Command LoadConf related method
 *	Description: Load alarm taking configuration from input string
 *
 *	@param argin Alarm string configuration:
 *               tag=;formula=;on_delay=;off_delay=;priority=;shlvd_time=;group=;message=;on_command=;off_command=;enabled=;handler=
 */
//--------------------------------------------------------
void AlarmManager::load_conf(Tango::DevString argin)
{
	DEBUG_STREAM << "AlarmManager::LoadConf()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::load_conf) ENABLED START -----*/
	
	//	Add your own code
	string tagname;
	string hndlrnamenew;
	string formula;
	string message;
	string group;
	string priority;
	string on_command;
	string off_command;
	string on_delay("0");
	string off_delay("0");
	string shlvd_time("-1");
	string enabled("1");
	string url;

	parse_conf(argin, tagname, hndlrnamenew, formula, message, group, priority,
		on_command, off_command, on_delay, off_delay, shlvd_time, enabled, url);
	string hndlrname = find_handler(tagname);
	auto itmapnew = handlerMap.find(hndlrname);
	if(itmapnew != handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' already configured in '"<<hndlrname<<"'";
		Tango::Except::throw_exception( \
					(const char*)"Already configured", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	itmapnew = handlerMap.find(hndlrnamenew);
	if(itmapnew == handlerMap.end())
	{
		stringstream tmp;
		tmp << "handler '" << hndlrname << "' not found";
		Tango::Except::throw_exception( \
					(const char*)"handler not found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	if(itmapnew->second.dp)
	{
		string load_str="tag="+tagname+";formula="+formula+";message="+message+";priority="+priority+
		";group="+group+		";shlvd_time="+shlvd_time+";on_delay="+on_delay+";off_delay="+off_delay+
		";on_command="+on_command+";off_command="+off_command+";url="+url+";enabled="+enabled;
		Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
		Tango::DeviceData Din;
		Din << load_argin;
		itmapnew->second.dp->command_inout("Load",Din);
	}
	else
	{
		stringstream tmp;
		tmp << "handler " << itmapnew->first << " Not Responding";
		Tango::Except::throw_exception( \
					(const char*)"Error", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::load_conf
}
//--------------------------------------------------------
/**
 *	Command SearchAlarmConf related method
 *	Description: Return list of configured alarm strings matching the filter string
 *
 *	@param argin String containing a filter for output, if empty or * return all alarms
 *	@returns Alarm string configuration:
 *           tag=;formula=;on_delay=;off_delay=;priority=;shlvd_time=;group=;message=;on_command=;off_command=;enabled=;handler=
 */
//--------------------------------------------------------
Tango::DevVarStringArray *AlarmManager::search_alarm_conf(Tango::DevString argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "AlarmManager::SearchAlarmConf()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::search_alarm_conf) ENABLED START -----*/
	
	//	Add your own code
	string filter(argin);
	vector<string> complete_list;
	DEBUG_STREAM << "AlarmManager::SearchAlarmConf()  - complete list -> size=" << complete_list.size() << endl;
	for(handler_map_t::iterator itmap = handlerMap.begin(); itmap != handlerMap.end(); itmap++)
	{
		vector<string> search_result;
		Tango::DeviceData Din;
		try
		{
			Din << filter;
			if(itmap->second.dp)
			{
				itmap->second.dp->command_inout("SearchAlarm",Din) >> search_result;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to SearchAlarm from " << itmap->first;
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to SearchAlarm from " << itmap->first;
		}
		DEBUG_STREAM << "AlarmManager::SearchAlarmConf()  - partial list -> size=" << search_result.size() << endl;
		for(auto &it : search_result)
		{
			complete_list.push_back(it+";handler="+itmap->first);
		}
		DEBUG_STREAM << "AlarmManager::SearchAlarmConf()  - building complete list -> size=" << complete_list.size() << endl;
	}

	argout = new Tango::DevVarStringArray();
	argout->length(complete_list.size());
	size_t i = 0;
	for (const auto &it : complete_list)
	{
		DEBUG_STREAM << "AlarmManager::SearchAlarmConf()  - result list -> copying=" << it << endl;	
		(*argout)[i] = CORBA::string_dup(it.c_str());
		i++;
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::search_alarm_conf
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ModifyConf related method
 *	Description: Modify alarm taking configuration from input string
 *
 *	@param argin Alarm string configuration:
 *               tag=;formula=;on_delay=;off_delay=;priority=;shlvd_time=;group=;message=;on_command=;off_command=;enabled=;handler=
 */
//--------------------------------------------------------
void AlarmManager::modify_conf(Tango::DevString argin)
{
	DEBUG_STREAM << "AlarmManager::ModifyConf()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::modify_conf) ENABLED START -----*/
	
	//	Add your own code
	string tagname;
	string hndlrnamenew;
	string formula;
	string message;
	string group;
	string priority;
	string on_command;
	string off_command;
	string on_delay("0");
	string off_delay("0");
	string shlvd_time("-1");
	string enabled("1");
	string url;

	parse_conf(argin, tagname, hndlrnamenew, formula, message, group, priority,
		on_command, off_command, on_delay, off_delay, shlvd_time, enabled, url);
	string hndlrname = find_handler(tagname);
	auto itmapold = handlerMap.find(hndlrname);
	if(itmapold == handlerMap.end())
	{
		stringstream tmp;
		tmp << "Alarm '" << tagname << "' Not Found";
		Tango::Except::throw_exception( \
					(const char*)"Not Found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	auto itmapnew = handlerMap.find(hndlrnamenew);
	if(itmapnew == handlerMap.end())
	{
		stringstream tmp;
		tmp << "handler '" << hndlrnamenew << "' not found";
		Tango::Except::throw_exception( \
					(const char*)"handler not found", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
	}

	if(compare_tango_names(hndlrnamenew, hndlrname) == false) //modify in same handler
	{
		if(itmapold->second.dp)
		{
			string load_str="tag="+tagname+";formula="+formula+";message="+message+";priority="+priority+
			";group="+group+		";shlvd_time="+shlvd_time+";on_delay="+on_delay+";off_delay="+off_delay+
			";on_command="+on_command+";off_command="+off_command+";url="+url+";enabled="+enabled;
			Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
			Tango::DeviceData Din;
			Din << load_argin;
			itmapold->second.dp->command_inout("Modify",Din);
		}
		else
		{
			stringstream tmp;
			tmp << "handler " << itmapold->first << " Not Responding";
			Tango::Except::throw_exception( \
						(const char*)"Error", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
	}
	else	//changed handler
	{
		if(itmapnew->second.dp)
		{
			string load_str="tag="+tagname+";formula="+formula+";message="+message+";priority="+priority+
			";group="+group+		";shlvd_time="+shlvd_time+";on_delay="+on_delay+";off_delay="+off_delay+
			";on_command="+on_command+";off_command="+off_command+";url="+url+";enabled="+enabled;
			Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
			Tango::DeviceData Din;
			Din << load_argin;
			itmapnew->second.dp->command_inout("Load",Din);
		}
		else
		{
			stringstream tmp;
			tmp << "handler " << itmapnew->first << " Not Responding";
			Tango::Except::throw_exception( \
						(const char*)"Error", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
		if(itmapold->second.dp)
		{
			Tango::DeviceData Din,Din2;
			vector<string> vtag;
			vtag.push_back(tagname);
			Din << tagname;
			Din2 << vtag;
			itmapold->second.dp->command_inout("Ack",Din2);
			itmapold->second.dp->command_inout("Remove",Din);
		}
		else
		{
			stringstream tmp;
			tmp << "handler " << itmapold->first << " Not Responding";
			if(itmapnew->second.dp)
			{
				Tango::DeviceData Din,Din2;
				vector<string> vtag;
				vtag.push_back(tagname);
				Din << tagname;
				Din2 << vtag;
				itmapnew->second.dp->command_inout("Ack",Din2);
				itmapnew->second.dp->command_inout("Remove",Din);
			}
			Tango::Except::throw_exception( \
						(const char*)"Error", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::modify_conf
}
//--------------------------------------------------------
/**
 *	Command AddArchiver related method
 *	Description: Add AlarmName to archiver
 *
 *	@param argin AlarmName, Archiver, Strategy
 */
//--------------------------------------------------------
void AlarmManager::add_archiver(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "AlarmManager::AddArchiver()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::add_archiver) ENABLED START -----*/
	
	//	Add your own code
	vector<string> param;
	param << (*argin);
	if(param.size() != 3 && param.size() != 1)
	{
		Tango::Except::throw_exception( \
			(const char*)"BAD PARAM", \
			(const char*)"Expected at 3 parameters (name, archiver, strategy) or 0 (use attributes handler+tag, archiver, strategy)", \
			(const char*)__func__, Tango::ERR);
	}

	string attr, archiver, strategy;
	if(param.size() == 3)
	{
		attr=param[0];
		archiver=param[1];
		strategy=param[2];
	}
	else
	{
		//string attr=string(*attr_handler_read)+"/"+string(*attr_tag_read);
		attr=param[0];
		if(*attr_default_archiver_read)
		{
			archiver=defaultArchiver;
			strategy=defaultStrategy;
		}
		else
		{
			archiver=*attr_archiver_read;
			strategy=*attr_strategy_read;
		}
	}
	vector<string> tmp;
	tmp.push_back(attr);
	tmp.push_back(strategy);
	//copy here attr type, format from hdb++cm

	string handler, tag;
	find_handler_tag(attr, handler, tag);
	DEBUG_STREAM << __func__ << ": found handler '"<< handler <<"' for alarm '"<<tag<<"'"<<endl;
	auto itmap = handlerMap.find(handler);
	if(itmap != handlerMap.end())
	{
		if(itmap->second.dp)
		{
			Tango::AttributeInfo	info = itmap->second.dp->get_attribute_config(tag);
			int data_type = info.data_type;
			int data_format = info.data_format;
			int write_type = info.writable;
			stringstream types;
			types << data_type;
			tmp.push_back(types.str());
			types.str(std::string());
			types << data_format;
			tmp.push_back(types.str());
			types.str(std::string());
			types << write_type;
			tmp.push_back(types.str());
		}
	}
	Tango::DeviceData Din;
	Din << tmp;
	if(param.size() == 3)
	{
		std::unique_ptr<Tango::DeviceProxy> _hdbpp = std::unique_ptr<Tango::DeviceProxy>(new Tango::DeviceProxy(archiver));
		_hdbpp->command_inout("AttributeAdd",Din);
	}
	else
	{
		hdbpp->command_inout("AttributeAdd",Din);
	}
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::add_archiver
}
//--------------------------------------------------------
/**
 *	Command Rename related method
 *	Description: Rename alarm from old name to new name
 *
 *	@param argin Old name (fqdn or just attribute)
 *               New name (fwdn or just attribute)
 */
//--------------------------------------------------------
void AlarmManager::rename(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "AlarmManager::Rename()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(AlarmManager::rename) ENABLED START -----*/
	
	//	Add your own code
	vector<string> param;
	param << (*argin);
	if(param.size() != 2)
	{
		Tango::Except::throw_exception("BAD PARAM","Expected 2 arguments: old name and new name", __func__);
	}
	
	string oldname=param[0];
	string newname=param[1];
	string hndlr_old, hndlr_new;
	string tag_old, tag_new;
	find_handler_tag(oldname, hndlr_old, tag_old);
	find_handler_tag(newname, hndlr_new, tag_new);
	vector<string> oldname_parts;
	AlarmStringUtils::string_explode(AlarmStringUtils::get_only_attr_name(oldname), "/", oldname_parts);
	vector<string> newname_parts;
	AlarmStringUtils::string_explode(AlarmStringUtils::get_only_attr_name(newname), "/", newname_parts);
	if(hndlr_old.empty() || tag_old.empty() || hndlr_new.empty() || tag_new.empty())
	{
		DEBUG_STREAM << __func__ << ": oldname="<<oldname<<" ->"<< hndlr_old<<"/"<<tag_old<< " newname="<<newname<<" ->" << hndlr_new<<"/"<<tag_new;
		Tango::Except::throw_exception("Argin Error","Expected FQDN or just attribute names",__func__);
	}

	if(hndlr_old != hndlr_new || tag_old != tag_new)
	{
		DEBUG_STREAM << __func__ << ": renaming "<<hndlr_old<<" - " << tag_old << " to " << hndlr_new << " - " << tag_new;
		auto itmapold = handlerMap.find(hndlr_old);
		if(itmapold == handlerMap.end())
		{
			stringstream tmp;
			tmp << "Handler '" << hndlr_old << "' Not Found";
			Tango::Except::throw_exception( \
						(const char*)"Not Found", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
		auto itmapnew = handlerMap.find(hndlr_new);
		if(itmapnew == handlerMap.end())
		{
			stringstream tmp;
			tmp << "Handler '" << hndlr_new << "' Not Found";
			Tango::Except::throw_exception( \
						(const char*)"Not Found", \
						tmp.str(), \
						(const char*)__func__, Tango::ERR);
		}
		if(itmapold->second.dp && itmapnew->second.dp)
		{
			Tango::DeviceData Din, Dout;
			vector<string> cmd_param;
			cmd_param.push_back(tag_old);
			cmd_param.push_back("enabled");
			cmd_param.push_back("formula");
			cmd_param.push_back("group");
			cmd_param.push_back("message");
			cmd_param.push_back("off_command");
			cmd_param.push_back("off_delay");
			cmd_param.push_back("on_command");
			cmd_param.push_back("on_delay");
			cmd_param.push_back("priority");
			cmd_param.push_back("shlvd_time");
			cmd_param.push_back("url");
			Din << cmd_param;
			Dout = itmapold->second.dp->command_inout("GetAlarmInfo",Din);
			vector<string> resp;
			Dout >> resp;
			unordered_map<string,string> conf;
			AlarmStringUtils::string_vector2map(resp, "=", conf);
			string load_str="tag="+tag_new+";";
			try
			{
				load_str+="formula="+conf.at("formula")+";";
				string trimmsg = conf.at("message");
				if(trimmsg.size()>=2)
				{
					if(trimmsg.front()=='"' && trimmsg.back()=='"')
					{
						trimmsg.pop_back();
						trimmsg.erase(trimmsg.begin());
					}
				}
				load_str+="message="+trimmsg+";";
				load_str+="priority="+conf.at("priority")+";";
				load_str+="group="+conf.at("group")+";";
				load_str+="shlvd_time="+conf.at("shlvd_time")+";";
				load_str+="on_delay="+conf.at("on_delay")+";";
				load_str+="off_delay="+conf.at("off_delay")+";";
				load_str+="on_command="+conf.at("on_command")+";";
				load_str+="off_command="+conf.at("off_command")+";";
				load_str+="url="+conf.at("url")+";";
				load_str+="enabled="+conf.at("enabled");
			}
			catch(const std::out_of_range& e)
			{
				stringstream tmp;
				tmp << "Configuration parsing error: " << e.what();
				DEBUG_STREAM << __func__<< ": " << tmp.str() << endl;
				Tango::Except::throw_exception("Configuration Error",tmp.str(),__func__);
			}

			Tango::DevString load_argin = CORBA::string_dup(load_str.c_str());
			Tango::DeviceData Din2;
			Din2 << load_argin;
			itmapnew->second.dp->command_inout("Load",Din2);
			try
			{
				//Tango::DevString remove_argin = CORBA::string_dup(tag_old.c_str());
				Tango::DeviceData Din,Din2;
				vector<string> vtag;
				vtag.push_back(tag_old);
				Din << tag_old;
				Din2 << vtag;
				itmapold->second.dp->command_inout("Ack",Din2);
				itmapold->second.dp->command_inout("Remove",Din);
			}
			catch(Tango::DevFailed &e)
			{
				stringstream tmp;
				tmp << "Error removing old : " << tag_old << " err=" << e.errors[0].desc;
				DEBUG_STREAM << __func__<< ": " << tmp.str() << endl;
				//Tango::DevString remove_argin = CORBA::string_dup(tag_new.c_str());
				Tango::DeviceData Din,Din2;
				vector<string> vtag;
				vtag.push_back(tag_new);
				Din << tag_new;
				Din2 << vtag;
				itmapnew->second.dp->command_inout("Ack",Din2);
				itmapnew->second.dp->command_inout("Remove",Din);
				Tango::Except::throw_exception("Remove Error",tmp.str(),__func__);
			}
		}
	}
	else
	{
		DEBUG_STREAM << __func__ << ": Same name "<<hndlr_old<<" - " << tag_old << " and " << hndlr_new << " - " << tag_new;
	}

	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::rename
}
//--------------------------------------------------------
/**
 *	Method      : AlarmManager::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void AlarmManager::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(AlarmManager::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	AlarmManager::add_dynamic_commands
}

/*----- PROTECTED REGION ID(AlarmManager::namespace_ending) ENABLED START -----*/

//	Additional Methods
string AlarmManager::find_handler(const string &tagname)
{
	DEBUG_STREAM << __func__<< ": entering with " << tagname;
	string handler("");
	for(auto itmap = handlerMap.begin(); itmap != handlerMap.end(); ++itmap)
	{
		Tango::DeviceAttribute Dout;
		try
		{
			if(itmap->second.dp)
			{
				Dout = itmap->second.dp->read_attribute("alarmList");
				if(!Dout.is_empty())
					Dout >> itmap->second.alm_list;
			}
			else
			{
				INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
				itmap->second.alm_list.clear();
			}
		}
		catch(Tango::DevFailed &e)
		{
			INFO_STREAM << __func__<<": unable to read alarmList from " << itmap->first;
			itmap->second.alm_list.clear();
		}
		for(auto itattr : itmap->second.alm_list)
		{
			if(tagname.length() != 0 && itattr == tagname)	
			{
				DEBUG_STREAM << __func__<< ": FOUND " << itattr;
				handler = itmap->first;
				return handler;
			}
		}
	}
	return handler;
}
	
	
void AlarmManager::parse_conf(string conf, string &tagname, string &hndlrnamenew, string &formula,
	string &message, string &group, string &priority, string &on_command, string &off_command,
	string &on_delay, string &off_delay, string &shlvd_time, string &enabled, string &url)
{
	vector<string> vconf;
	unordered_map<string,string> mconf;
	AlarmStringUtils::string_explode(conf, ";", vconf); //TODO: escape ;
	AlarmStringUtils::string_vector2map(vconf, "=", mconf);
	try{
		cout << "vconf.size="<<vconf.size()<< " mconf.size="<<mconf.size() << endl;
		tagname=mconf.at("tag");
		cout << "tag="<<tagname << endl;
		hndlrnamenew=mconf.at("handler");
		formula=mconf.at("formula");
		message=mconf.at("message");
		group=mconf.at("group");
		priority=mconf.at("priority");
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error: tag=" << tagname << " handler="<<hndlrnamenew << " formula="<<formula << " message="<<message<< " group="<<group<< " priority="<<priority;
		DEBUG_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception("Configuration Error",tmp.str(),__func__);
	}
	try
	{
		on_command=mconf.at("on_command");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
	try
	{
		off_command=mconf.at("off_command");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
	try
	{
		on_delay=mconf.at("on_delay");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
	try
	{
		off_delay=mconf.at("off_delay");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
	try
	{
		shlvd_time=mconf.at("shlvd_time");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
	try
	{
		enabled=mconf.at("enabled");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
	try
	{
		url=mconf.at("url");
	}
	catch(const std::out_of_range& e)
	{
		DEBUG_STREAM << __func__<< ": Configuration parsing error: " << e.what() << endl;
	}
}

void AlarmManager::find_handler_tag(string &name, string &handler, string &tag)
{
	vector<string> vname;
	AlarmStringUtils::string_explode(name, "/", vname);
	if(vname.size() == 1)
	{
		handler = find_handler(name);
		tag=name;
		DEBUG_STREAM << __func__ << ": found handler " << handler << " for  " << name;
	}
	else if(vname.size() == 4 || vname.size() == 6)
	{
		AlarmStringUtils::fix_tango_host(name);
		AlarmStringUtils::split_tag_handler(name, handler, tag);
		DEBUG_STREAM << __func__ << ": split in handler " << handler << " and tag " << tag;
	}
	else
	{
		DEBUG_STREAM << __func__ << ": BAD " << name << " has " << vname.size()-1 << " /";
	}

}

/*----- PROTECTED REGION END -----*/	//	AlarmManager::namespace_ending
} //	namespace
